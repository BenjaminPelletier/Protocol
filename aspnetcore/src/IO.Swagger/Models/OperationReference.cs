/*
 * UTM DSS/USS API
 *
 * Interface to Discovery and Synchronization Service (DSS) and UAS Service Suppliers (USS) used by participating clients to discover and interoperate.  Unless otherwise specified, fields specified in a message but not declared in the API shall be ignored.
 *
 * OpenAPI spec version: 1.0.0-oas3
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// An OperationReference (area in which an Operation is being conducted, along with other high-level information, but no details).  The DSS reports only these references and clients must exchange details and additional information peer-to-peer.
    /// </summary>
    [DataContract]
    public partial class OperationReference : IEquatable<OperationReference>
    { 
        /// <summary>
        /// Unique identifier for this OperationReference.
        /// </summary>
        /// <value>Unique identifier for this OperationReference.</value>
        [Required]
        [DataMember(Name="id")]
        public AnyOfOperationReferenceId Id { get; set; }

        /// <summary>
        /// Gets or Sets DetailsUrl
        /// </summary>
        [Required]
        [DataMember(Name="details_url")]
        public OperationDetailsURL DetailsUrl { get; set; }

        /// <summary>
        /// Gets or Sets FeedbackUrl
        /// </summary>
        [DataMember(Name="feedback_url")]
        public FeedbackURL FeedbackUrl { get; set; }

        /// <summary>
        /// Created by the DSS and based on creating client’s ID (via access token).  Used for restricting mutation and deletion operations to owner.
        /// </summary>
        /// <value>Created by the DSS and based on creating client’s ID (via access token).  Used for restricting mutation and deletion operations to owner.</value>
        [Required]
        [DataMember(Name="owner")]
        public string Owner { get; set; }

        /// <summary>
        /// Beginning time of Operation.  RFC 3339 format, per OpenAPI specification.
        /// </summary>
        /// <value>Beginning time of Operation.  RFC 3339 format, per OpenAPI specification.</value>
        [Required]
        [DataMember(Name="time_start")]
        public  TimeStart { get; set; }

        /// <summary>
        /// End time of Operation.  RFC 3339 format, per OpenAPI specification.
        /// </summary>
        /// <value>End time of Operation.  RFC 3339 format, per OpenAPI specification.</value>
        [Required]
        [DataMember(Name="time_end")]
        public  TimeEnd { get; set; }

        /// <summary>
        /// Opaque version number of this OperationReference, used for updating or deleting the OperationReference.  Only populated by the DSS for OperationReferences owned by the requesting client.  Must be populated by a USS when notifying a subscriber of an altered Operation or providing full Operation information.
        /// </summary>
        /// <value>Opaque version number of this OperationReference, used for updating or deleting the OperationReference.  Only populated by the DSS for OperationReferences owned by the requesting client.  Must be populated by a USS when notifying a subscriber of an altered Operation or providing full Operation information.</value>
        [DataMember(Name="ovn")]
        public AnyOfOperationReferenceOvn Ovn { get; set; }

        /// <summary>
        /// Gets or Sets Priority
        /// </summary>
        [Required]
        [DataMember(Name="priority")]
        public OperationPriority Priority { get; set; }

        /// <summary>
        /// If specified as true by the DSS, the details for this Operation may not be accessible.  The OVN for this OperationReference may be omitted when deconflicting an Operation, at which point this Operation will be disabled.
        /// </summary>
        /// <value>If specified as true by the DSS, the details for this Operation may not be accessible.  The OVN for this OperationReference may be omitted when deconflicting an Operation, at which point this Operation will be disabled.</value>
        [DataMember(Name="uss_may_be_down")]
        public bool? UssMayBeDown { get; set; }

        /// <summary>
        /// If specified as true by the DSS, this Operation has been disabled and will not be permitted to transition to Activated.  This means aircraft for this Operation will not be permitted to fly pursuant to this Operation, so this Operation may be ignored when planning and its OVN does not need to be provided to prove relevant airspace knowledge.
        /// </summary>
        /// <value>If specified as true by the DSS, this Operation has been disabled and will not be permitted to transition to Activated.  This means aircraft for this Operation will not be permitted to fly pursuant to this Operation, so this Operation may be ignored when planning and its OVN does not need to be provided to prove relevant airspace knowledge.</value>
        [DataMember(Name="disabled")]
        public bool? Disabled { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class OperationReference {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  DetailsUrl: ").Append(DetailsUrl).Append("\n");
            sb.Append("  FeedbackUrl: ").Append(FeedbackUrl).Append("\n");
            sb.Append("  Owner: ").Append(Owner).Append("\n");
            sb.Append("  TimeStart: ").Append(TimeStart).Append("\n");
            sb.Append("  TimeEnd: ").Append(TimeEnd).Append("\n");
            sb.Append("  Ovn: ").Append(Ovn).Append("\n");
            sb.Append("  Priority: ").Append(Priority).Append("\n");
            sb.Append("  UssMayBeDown: ").Append(UssMayBeDown).Append("\n");
            sb.Append("  Disabled: ").Append(Disabled).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((OperationReference)obj);
        }

        /// <summary>
        /// Returns true if OperationReference instances are equal
        /// </summary>
        /// <param name="other">Instance of OperationReference to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OperationReference other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Id == other.Id ||
                    Id != null &&
                    Id.SequenceEqual(other.Id)
                ) && 
                (
                    DetailsUrl == other.DetailsUrl ||
                    DetailsUrl != null &&
                    DetailsUrl.Equals(other.DetailsUrl)
                ) && 
                (
                    FeedbackUrl == other.FeedbackUrl ||
                    FeedbackUrl != null &&
                    FeedbackUrl.Equals(other.FeedbackUrl)
                ) && 
                (
                    Owner == other.Owner ||
                    Owner != null &&
                    Owner.Equals(other.Owner)
                ) && 
                (
                    TimeStart == other.TimeStart ||
                    TimeStart != null &&
                    TimeStart.SequenceEqual(other.TimeStart)
                ) && 
                (
                    TimeEnd == other.TimeEnd ||
                    TimeEnd != null &&
                    TimeEnd.SequenceEqual(other.TimeEnd)
                ) && 
                (
                    Ovn == other.Ovn ||
                    Ovn != null &&
                    Ovn.SequenceEqual(other.Ovn)
                ) && 
                (
                    Priority == other.Priority ||
                    Priority != null &&
                    Priority.Equals(other.Priority)
                ) && 
                (
                    UssMayBeDown == other.UssMayBeDown ||
                    UssMayBeDown != null &&
                    UssMayBeDown.Equals(other.UssMayBeDown)
                ) && 
                (
                    Disabled == other.Disabled ||
                    Disabled != null &&
                    Disabled.Equals(other.Disabled)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Id != null)
                    hashCode = hashCode * 59 + Id.GetHashCode();
                    if (DetailsUrl != null)
                    hashCode = hashCode * 59 + DetailsUrl.GetHashCode();
                    if (FeedbackUrl != null)
                    hashCode = hashCode * 59 + FeedbackUrl.GetHashCode();
                    if (Owner != null)
                    hashCode = hashCode * 59 + Owner.GetHashCode();
                    if (TimeStart != null)
                    hashCode = hashCode * 59 + TimeStart.GetHashCode();
                    if (TimeEnd != null)
                    hashCode = hashCode * 59 + TimeEnd.GetHashCode();
                    if (Ovn != null)
                    hashCode = hashCode * 59 + Ovn.GetHashCode();
                    if (Priority != null)
                    hashCode = hashCode * 59 + Priority.GetHashCode();
                    if (UssMayBeDown != null)
                    hashCode = hashCode * 59 + UssMayBeDown.GetHashCode();
                    if (Disabled != null)
                    hashCode = hashCode * 59 + Disabled.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(OperationReference left, OperationReference right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(OperationReference left, OperationReference right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
